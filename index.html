<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jemini Installer Demo</title>
    <link rel="icon" href="assets/gemini.png" type="image/png">

    <style>
        body {
            /* Background determines the "Desktop" look behind the window */
            background-color: #0d0e11; 
            background-image: radial-gradient(#1a1d23 1px, transparent 1px);
            background-size: 20px 20px;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* The Window Container */
        .window-frame {
            position: relative;
            width: 800px;
            height: 600px; 
            box-shadow: 0 20px 50px rgba(0,0,0,0.5), 0 0 0 1px #333;
            border-radius: 8px;
            overflow: hidden;
            background-color: #14171c; /* Match app background */
        }

        /* Drag region for Electron (confined to the window frame) */
        .drag-region {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 32px;
            z-index: 100;
            /* In a real frameless window, this makes it draggable */
            -webkit-app-region: drag; 
        }

        canvas {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            display: block;
        }
    </style>
</head>
<body>

    <div class="window-frame">
        <div class="drag-region"></div>
        <canvas id="gameCanvas" width="800" height="600"></canvas> 
    </div>

    <script type="module">
        // Import font data instead of hardcoding it
        import { fontDataRaw } from './font.js';
        
        // Electron IPC (available with nodeIntegration: true)
        const { ipcRenderer } = require('electron');

        // --- 1. CONFIGURATION & STATE ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Scratch canvas for screenshot masking
        const scratchCanvas = document.createElement('canvas');
        const sCtx = scratchCanvas.getContext('2d');

        let mouseX = 0;
        let mouseY = 0;
        let isMouseDown = false;
        let charData = null;

        // Installer States
        const STATE = {
            WELCOME: 0,
            INSTALLING: 1,
            COMPLETE: 2
        };
        let currentState = STATE.WELCOME;
        
        // Progress State
        let installProgress = 0; 
        let statusText = "Ready to install";

        // Options State
        let createShortcut = true;

        // Animation State
        let screenshotOpacity = 1.0;

        // --- 2. IMAGES ---
        const fontImage = new Image();
        fontImage.src = './pixelFont.png'; 

        const iconGemini = new Image();
        iconGemini.src = 'assets/gemini.png';
        
        const screenshotImage = new Image();
        screenshotImage.src = 'assets/screenshot.png';

        const exitIcon = new Image();
        exitIcon.src = 'assets/exit-icon.png';

        // --- 3. ENGINE HELPERS ---

        function parseFontData(fntString) {
            const chars = {};
            const lines = fntString.split('\n');
            lines.forEach(line => {
                if (line.startsWith('char id=')) {
                    const id = parseInt(line.match(/id=(\d+)/)[1]);
                    const x = parseInt(line.match(/x=(\d+)/)[1]);
                    const y = parseInt(line.match(/y=(\d+)/)[1]);
                    const width = parseInt(line.match(/width=(\d+)/)[1]);
                    const height = parseInt(line.match(/height=(\d+)/)[1]);
                    const xoffset = parseInt(line.match(/xoffset=(\d+)/)[1]);
                    const yoffset = parseInt(line.match(/yoffset=(\d+)/)[1]);
                    const xadvance = parseInt(line.match(/xadvance=(\d+)/)[1]);
                    chars[id] = { x, y, width, height, xoffset, yoffset, xadvance };
                }
            });
            return chars;
        }

        function measureTextWidth(text, chars, scale = 1) {
            let width = 0;
            for (let i = 0; i < text.length; i++) {
                const charCode = text.charCodeAt(i);
                if (chars[charCode]) width += chars[charCode].xadvance * scale;
            }
            return width;
        }

        function wrapText(text, chars, scale, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';
            
            for (let word of words) {
                const testLine = currentLine ? currentLine + ' ' + word : word;
                const testWidth = measureTextWidth(testLine, chars, scale);
                
                if (testWidth > maxWidth && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            }
            
            if (currentLine) {
                lines.push(currentLine);
            }
            
            // Limit to 2 lines max
            if (lines.length > 2) {
                const line1 = lines[0];
                const line2 = lines.slice(1).join(' ');
                // Truncate second line if needed
                let line2Width = measureTextWidth(line2, chars, scale);
                if (line2Width > maxWidth) {
                    // Truncate second line
                    let truncated = '';
                    for (let i = 0; i < line2.length; i++) {
                        const test = truncated + line2[i];
                        if (measureTextWidth(test, chars, scale) > maxWidth - 20) break;
                        truncated = test;
                    }
                    return [line1, truncated + '...'];
                }
                return [line1, line2];
            }
            
            return lines;
        }

        function renderText(ctx, img, text, chars, x, y, scale = 1) {
            let cursorX = x;
            ctx.imageSmoothingEnabled = false;

            for (let i = 0; i < text.length; i++) {
                const charCode = text.charCodeAt(i);
                const char = chars[charCode];
                if (char) {
                    if (char.width > 0 && char.height > 0) {
                        ctx.drawImage(
                            img, 
                            char.x, char.y, char.width, char.height, 
                            cursorX + (char.xoffset * scale), y + (char.yoffset * scale), 
                            char.width * scale, char.height * scale
                        );
                    }
                    cursorX += char.xadvance * scale;
                }
            }
        }

        function rectHit(x, y, w, h, mx, my) {
            return mx >= x && mx <= x + w && my >= y && my <= y + h;
        }

        // --- 4. UI COMPONENTS ---

        function drawButton(text, x, y, w, h, chars, img, opacity = 1.0) {
            // Expand hit area significantly for better usability
            const hitPadding = 20; 
            const hover = rectHit(x - hitPadding, y - hitPadding, w + (hitPadding*2), h + (hitPadding*2), mouseX, mouseY);
            
            ctx.globalAlpha = opacity;
            
            if (hover) {
                ctx.fillStyle = "rgb(64, 64, 76)";
            } else {
                ctx.fillStyle = "rgb(46, 46, 56)";
            }

            ctx.beginPath();
            ctx.roundRect(x, y, w, h, 4);
            ctx.fill();

            const textScale = 2;
            const txt_w = measureTextWidth(text, chars, textScale);
            const txt_h = 12 * textScale;

            renderText(
                ctx, img, text, chars, 
                x + (w - txt_w) / 2, 
                y + (h - txt_h) / 2, 
                textScale
            );

            ctx.globalAlpha = 1.0;
            return hover; 
        }

        function drawProgressBar(x, y, w, h, percent, opacity = 1.0) {
            ctx.globalAlpha = opacity;
            
            // Background (Dark)
            ctx.fillStyle = "rgb(20, 23, 28)"; 
            ctx.fillRect(x, y, w, h); 

            // Outline (Black)
            ctx.strokeStyle = "#000000";
            ctx.lineWidth = 1;
            ctx.strokeRect(x - 0.5, y - 0.5, w + 1, h + 1);

            // Smooth Gradient Fill (Non-pixel art)
            if (percent > 0) {
                const fillW = (w * percent) / 100;
                
                // Gradient Flow: #3284f9 -> #cd5161 -> #41b37c -> #c9a132
                const gradient = ctx.createLinearGradient(x, 0, x + w, 0);
                gradient.addColorStop(0, "#3284f9");
                gradient.addColorStop(0.33, "#cd5161");
                gradient.addColorStop(0.66, "#41b37c");
                gradient.addColorStop(1, "#c9a132");
                
                ctx.fillStyle = gradient;
                
                // Draw smooth rect
                ctx.fillRect(x, y, fillW, h); 
            }
            ctx.globalAlpha = 1.0;
        }

        // --- 5. LOGIC ---
        
        let installInterval = null;
        let fadeInterval = null;
        
        function startInstallation() {
            currentState = STATE.INSTALLING;
            statusText = "Initializing...";
            installProgress = 0;

            // Start fade out animation
            fadeInterval = setInterval(() => {
                if (screenshotOpacity > 0) {
                    screenshotOpacity -= 0.01; 
                    if (screenshotOpacity < 0) screenshotOpacity = 0;
                }
            }, 30);
            
            // Send install request to Electron
            try {
                ipcRenderer.send('install', {
                    createDesktopShortcut: createShortcut
                });
            } catch (e) {
                console.error('Failed to send install request:', e);
                statusText = "Error: Failed to start installation";
            }
        }

        function launchApp() {
            // Launch the installed app
            try {
                ipcRenderer.send('launch-app');
            } catch (e) {
                console.error('Failed to launch app:', e);
                // Fallback: try to close window
                try {
                    ipcRenderer.send('close-window');
                } catch (e2) {
                    window.close();
                }
            }
        }
        
        function closeWindow() {
            // Close the installer window  
            try {
                ipcRenderer.send('close-window');
            } catch (e) {
                window.close();
            }
        }
        
        // Listen for progress updates from Electron
        try {
            ipcRenderer.on('progress', (event, message) => {
                statusText = message;
                // Update progress based on message
                if (message.includes('Creating .love')) {
                    installProgress = 10;
                } else if (message.includes('Merging')) {
                    installProgress = 30;
                } else if (message.includes('Replacing icon')) {
                    installProgress = 50;
                } else if (message.includes('Copying dependencies')) {
                    installProgress = 65;
                } else if (message.includes('Installing to system')) {
                    installProgress = 80;
                } else if (message.includes('Creating shortcuts')) {
                    installProgress = 95;
                }
            });
            
            ipcRenderer.on('complete', (event, result) => {
                if (installInterval) clearInterval(installInterval);
                if (fadeInterval) clearInterval(fadeInterval);
                
                if (result.success) {
                    installProgress = 100;
                    statusText = "Installation Complete!";
                    setTimeout(() => {
                        currentState = STATE.COMPLETE;
                    }, 500);
                } else {
                    statusText = "Installation Failed: " + (result.error || "Unknown error");
                    // Stay in INSTALLING state or show error
                }
            });
        } catch (e) {
            console.error('Failed to set up IPC listeners:', e);
        }

        // --- 6. MAIN LOOP ---

        // Mouse listeners - UPDATED for Window Frame offset
        window.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        window.addEventListener('mousedown', () => { isMouseDown = true; });
        window.addEventListener('mouseup', () => { isMouseDown = false; });

        window.addEventListener('click', () => {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const contentOffsetY = 35; 

            // Exit button click
            // Adjusted position (down to 20px, left to width-45)
            const exitX = canvas.width - 45;
            const exitY = 20;
            const exitSize = 22;
            const hitPad = 10;
            
            if (rectHit(exitX - hitPad, exitY - hitPad, exitSize + hitPad*2, exitSize + hitPad*2, mouseX, mouseY)) {
                closeWindow();
            }

            if (currentState === STATE.WELCOME) {
                // Install Button Hit Check (Matches drawButton coordinates)
                const btnW = 200;
                const btnH = 50;
                const btnX = cx - (btnW/2);
                const btnY = cy + 80 + contentOffsetY;
                
                // Larger hit padding for usability
                const btnHitPad = 20;
                if (rectHit(btnX - btnHitPad, btnY - btnHitPad, btnW + (btnHitPad*2), btnH + (btnHitPad*2), mouseX, mouseY)) {
                    startInstallation();
                }
            } else if (currentState === STATE.INSTALLING) {
                // Status text click to copy
                const groupCenterY = cy + contentOffsetY;
                const subScale = 1.5;
                const maxTextWidth = 700;
                const wrappedLines = wrapText(statusText, charData, subScale, maxTextWidth);
                const lineHeight = 20 * subScale;
                const statusY = groupCenterY + 30;
                const statusH = wrappedLines.length * lineHeight;
                const statusW = maxTextWidth;
                
                if (rectHit(cx - statusW/2, statusY - 5, statusW, statusH + 10, mouseX, mouseY)) {
                    // Copy status text to clipboard
                    navigator.clipboard.writeText(statusText).then(() => {
                        console.log('Status text copied to clipboard');
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                    });
                }
            } else if (currentState === STATE.COMPLETE) {
                // Launch Button
                const btnW = 200;
                const btnH = 50;
                const btnX = cx - (btnW/2);
                const btnY = cy + 40; // Updated to match loop
                const btnHitPad = 20;
                
                if (rectHit(btnX - btnHitPad, btnY - btnHitPad, btnW + (btnHitPad*2), btnH + (btnHitPad*2), mouseX, mouseY)) {
                    launchApp();
                }

                // Checkbox Hit Check
                const chkText = "Create Desktop Shortcut";
                const chkScale = 2;
                const chkW = measureTextWidth(chkText, charData, chkScale);
                const chkSize = 16; // SMALLER: 16px (was 20px)
                const totalW = chkSize + 10 + chkW;
                
                // Adjusted Checkbox Y for Hit Logic (should match loop drawing logic)
                const chkX = cx - (totalW / 2);
                const chkY = cy - 4; // Adjusted for smaller size to keep centered
                
                if (rectHit(chkX - 10, chkY - 10, totalW + 20, chkSize + 20, mouseX, mouseY)) {
                    createShortcut = !createShortcut;
                }
            }
        });

        function loop() {
            // Background
            ctx.fillStyle = "#14171c";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let isHovering = false;

            if (charData && fontImage.complete) {
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                const contentOffsetY = 35; // Shifts everything down to center visually in 600px window

                // --- 1. SCREENSHOT (Background Layer) ---
                if (screenshotImage.complete && screenshotOpacity > 0) {
                    // Use a scratch canvas to handle masking transparently
                    const shotW = 560; 
                    const shotH = 350;
                    const padding = 150; // Increased space for soft glow
                    
                    scratchCanvas.width = shotW + padding;
                    scratchCanvas.height = shotH + padding;
                    
                    // Clear scratch
                    sCtx.clearRect(0, 0, scratchCanvas.width, scratchCanvas.height);
                    
                    const sX = padding/2;
                    const sY = padding/2;

                    // 1. Draw Glow (Behind Image) - Soft Elliptical Light
                    sCtx.save();
                    const gCx = sX + shotW / 2;
                    const gCy = sY + shotH / 2;
                    const aspectRatio = shotW / shotH;
                    
                    sCtx.translate(gCx, gCy);
                    sCtx.scale(aspectRatio, 1);
                    
                    // Radius covers image + extra for soft edge
                    const radius = (shotH / 2) + 60; 
                    
                    const glow = sCtx.createRadialGradient(0, 0, shotH * 0.2, 0, 0, radius);
                    glow.addColorStop(0, 'rgba(76, 76, 89, 0.4)'); // Inner glow
                    glow.addColorStop(1, 'rgba(76, 76, 89, 0)');    // Fade to transparent
                    
                    sCtx.fillStyle = glow;
                    sCtx.fillRect(-radius, -radius, radius * 2, radius * 2);
                    sCtx.restore();

                    // 2. Draw Image
                    sCtx.drawImage(screenshotImage, sX, sY, shotW, shotH);

                    // 3. Draw Outline
                    sCtx.strokeStyle = '#4c4c59';
                    sCtx.lineWidth = 1;
                    sCtx.strokeRect(sX, sY, shotW, shotH);
                    
                    // 4. Fade to Transparent (Masking)
                    sCtx.globalCompositeOperation = 'destination-out';
                    
                    const gradient = sCtx.createLinearGradient(0, sY, 0, sY + shotH);
                    gradient.addColorStop(0, 'rgba(0,0,0,0)'); // Top fully visible
                    gradient.addColorStop(0.3, 'rgba(0,0,0,0)'); 
                    gradient.addColorStop(1, 'rgba(0,0,0,1)'); // Bottom removed
                    
                    sCtx.fillStyle = gradient;
                    sCtx.fillRect(0, 0, scratchCanvas.width, scratchCanvas.height);
                    
                    // Reset composite
                    sCtx.globalCompositeOperation = 'source-over';

                    // --- DRAW TO MAIN CANVAS ---
                    ctx.save();
                    ctx.globalAlpha = screenshotOpacity;
                    
                    // Calculate Y with offset.
                    const destX = cx - (scratchCanvas.width / 2);
                    const destY = ((canvas.height - shotH) / 2) - 60 - (padding/2) + contentOffsetY;

                    ctx.drawImage(scratchCanvas, destX, destY);
                    
                    ctx.restore();
                }

                // --- 2. BRANDING ---
                if (iconGemini.complete) {
                    ctx.drawImage(iconGemini, 25, 25, 33, 33);
                }
                renderText(ctx, fontImage, "JEMINI", charData, 70, 16, 3.85);

                // --- 2b. EXIT BUTTON ---
                if (exitIcon.complete) {
                    // Moved down to 20px, shifted left slightly more (width - 45)
                    const exitX = canvas.width - 45; 
                    const exitY = 20;
                    const exitSize = 22; 
                    
                    const hitPad = 10;
                    const isExitHover = rectHit(exitX - hitPad, exitY - hitPad, exitSize + hitPad*2, exitSize + hitPad*2, mouseX, mouseY);
                    if (isExitHover) {
                        ctx.globalAlpha = 1.0;
                        isHovering = true;
                    } else {
                        ctx.globalAlpha = 0.6;
                    }
                    ctx.drawImage(exitIcon, exitX, exitY, exitSize, exitSize);
                    ctx.globalAlpha = 1.0;
                }

                // --- 3. STATES ---
                if (currentState === STATE.WELCOME || currentState === STATE.INSTALLING) {
                    // Title Area (shifted by contentOffsetY)
                    const titleY = cy + 40 + contentOffsetY;
                    
                    if (currentState === STATE.WELCOME) {
                        // Title
                        const title = "Jemini Setup";
                        const titleScale = 4;
                        const tw = measureTextWidth(title, charData, titleScale);
                        renderText(ctx, fontImage, title, charData, cx - tw/2, titleY, titleScale);

                        // Subtitle
                        const sub = "First Public Release";
                        const subScale = 2;
                        ctx.globalAlpha = 0.6; 
                        const sw = measureTextWidth(sub, charData, subScale);
                        renderText(ctx, fontImage, sub, charData, cx - sw/2, titleY + 50, subScale);
                        ctx.globalAlpha = 1.0;

                        // Install Button
                        const btnHover = drawButton("INSTALL", cx - 100, titleY + 80, 200, 50, charData, fontImage);
                        if(btnHover) isHovering = true;
                    }
                    else if (currentState === STATE.INSTALLING) {
                        // Centered Grouping for Install State
                        // We center this group vertically in the space below the screenshot
                        const groupCenterY = cy + contentOffsetY; 
                        
                        // Title "Installing..."
                        const title = "Installing...";
                        const titleScale = 3;
                        const tw = measureTextWidth(title, charData, titleScale);
                        // Moved title up slightly to balance group
                        renderText(ctx, fontImage, title, charData, cx - tw/2, groupCenterY - 40, titleScale);

                        // Progress Bar takes place of button
                        // WIDER: 600px (was 500)
                        // THINNER: 6px (was 10)
                        drawProgressBar(cx - 300, groupCenterY, 600, 6, installProgress);

                        // Status Text (wrapped to 2 lines max)
                        const subScale = 1.5;
                        const maxTextWidth = 700; // Max width for text before wrapping
                        const wrappedLines = wrapText(statusText, charData, subScale, maxTextWidth);
                        const lineHeight = 20 * subScale; // Approximate line height
                        ctx.globalAlpha = 0.7;
                        for (let i = 0; i < wrappedLines.length; i++) {
                            const line = wrappedLines[i];
                            const lineW = measureTextWidth(line, charData, subScale);
                            renderText(ctx, fontImage, line, charData, cx - lineW/2, groupCenterY + 30 + (i * lineHeight), subScale);
                        }
                        ctx.globalAlpha = 1.0;
                    }
                }
                else if (currentState === STATE.COMPLETE) {
                    const title = "Installed!";
                    const titleScale = 4;
                    const tw = measureTextWidth(title, charData, titleScale);
                    // Moved title up slightly to ensure room for options
                    renderText(ctx, fontImage, title, charData, cx - tw/2, cy - 90, titleScale);
// --- CHECKBOX: Create Desktop Shortcut ---
                    const chkSize = 16 * 0.9; 
                    const chkGap = 10;
                    // UPDATED: Changed text to include '?' 
                    const chkText = "Create Desktop Shortcut?";
                    const chkScale = 2;
                    const chkW = measureTextWidth(chkText, charData, chkScale);
                    const totalW = chkSize + chkGap + chkW;
                    
                    const chkX = cx - (totalW / 2);
                    const chkY = cy + -15; 
                    
                    // UPDATED: Moved down 1px more (was +4, now +5)
                    const boxY = chkY + 5; 
                    
                    // Checkbox Interaction 
                    const isChkHover = rectHit(chkX - 5, chkY - 5, totalW + 10, chkSize + 10, mouseX, mouseY);
                    if (isChkHover) isHovering = true;

                    // Box
                    ctx.fillStyle = "#2e2e38"; 
                    ctx.fillRect(chkX, boxY, chkSize, chkSize);
                    
                    // Check Mark (Full Fill, #e8c522)
                    if (createShortcut) {
                        // UPDATED: Increased transparency to 15% (0.85 alpha)
                        ctx.globalAlpha = 0.85; 
                        
                        ctx.fillStyle = "#e8c522"; 
                        ctx.fillRect(chkX, boxY, chkSize, chkSize); 
                        
                        ctx.globalAlpha = 1.0; 
                    }
                    
                    // Label
                    // UPDATED: Base color is #a1a2a4. Hover is a slightly lighter grey (#c0c0c0) instead of white.
                    ctx.fillStyle = isChkHover ? "#c0c0c0" : "#a1a2a4"; 
                    renderText(ctx, fontImage, chkText, charData, chkX + chkSize + chkGap, chkY, chkScale);

                    // Launch Button
                    const btnHover = drawButton("LAUNCH", cx - 100, cy + 40, 200, 50, charData, fontImage);
                    if(btnHover) isHovering = true;
                }
            }

            canvas.style.cursor = isHovering ? 'pointer' : 'default';
            requestAnimationFrame(loop);
        }

        // Initialize
        fontImage.onload = () => {
            charData = parseFontData(fontDataRaw);
            loop();
        };
    </script>
</body>
</html>